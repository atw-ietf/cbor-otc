



cbor                                                     A. Wiethuechter
Internet-Draft                                               Independent
Intended status: Informational                                   S. Card
Expires: 12 May 2026                          Critical Technologies Inc.
                                                         8 November 2025


       CBOR Ordinal Type Compression for Value Groups & Map Keys
                         draft-atw-cbor-otc-00

Abstract

   This document standardizes a method to compress groupings of CBOR
   ordinal types such as integers and floats.  The concept is then
   applied to the specific case of using integers as keys in CBOR maps
   that can be used by protocol specifications to enable re-use of the
   most concise CBOR encodings.  Such compression to enable these
   encodings are desirable in highly constrained environments.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 12 May 2026.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.











Wiethuechter & Card        Expires 12 May 2026                  [Page 1]

Internet-Draft                    asdak                    November 2025


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Purpose . . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.2.  Background  . . . . . . . . . . . . . . . . . . . . . . .   3
       1.2.1.  Inspiration . . . . . . . . . . . . . . . . . . . . .   3
     1.3.  Scope . . . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.1.  Additional Definitions & Abbreviations  . . . . . . . . .   4
   3.  Ordinal Context Compression . . . . . . . . . . . . . . . . .   4
   4.  Using OGC for Keys in CBOR Maps . . . . . . . . . . . . . . .   5
     4.1.  Application Specific Context (ASC)  . . . . . . . . . . .   7
       4.1.1.  Inherited ASC . . . . . . . . . . . . . . . . . . . .   8
       4.1.2.  Direct ASC  . . . . . . . . . . . . . . . . . . . . .   8
       4.1.3.  Indirect ASC  . . . . . . . . . . . . . . . . . . . .   9
       4.1.4.  Mixed ASC . . . . . . . . . . . . . . . . . . . . . .   9
     4.2.  Supporting JSON . . . . . . . . . . . . . . . . . . . . .  10
   5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  10
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  10
   7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  10
     7.1.  Normative References  . . . . . . . . . . . . . . . . . .  10
     7.2.  Informative References  . . . . . . . . . . . . . . . . .  10
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  11

1.  Introduction

1.1.  Purpose

   Many applications may require very compact encodings on the wire to
   exchange data.  CBOR enables such compact encodings and with specific
   techniques can be further compressed.

   and with Major Type 5, herein referred to as a "map", enables
   flexible data models that remain compact by using integers as keys.








Wiethuechter & Card        Expires 12 May 2026                  [Page 2]

Internet-Draft                    asdak                    November 2025


   Existing practice is to define registries of integer values to be
   used a keys in CBOR that sometimes, depending on the use, also have a
   mapping to a JSON key.  These registries however are implicitly
   context based with no real encoding on wire to indicate what set of
   values to use without being in the know.

   A way to enable CBOR maps to explicitly indicate their "context",
   while also enabling compact encodings of keys, could be valuable for
   some applications.

1.2.  Background

   The most compact key form is the encoding in CBOR is 1+0 where the
   integer value (positive; Major Type 0 or negative; Major Type 1) is
   contained in the lower 5-bits of the CBOR byte and is limited to the
   range of -24 to 23.  Usually this range in a registry is reserved to
   the strongest of registration policies to ensure use is not abused
   and fair.

   This can result in a proliferation of registries, that applications
   create in their own namespaces, to gain access to the restricted or
   already allocated values in this desirable range.  This can cause
   interoperability issues when an application fails to, or improperly
   references, the wrong registry of values for a data structure such as
   a map.

1.2.1.  Inspiration

   The proposed solution for the above problem is inspired by a number
   of previous technologies and concepts: Motorola 6800 addressing
   modes, Asynchronous Transfer Mode (ATM), VPI (Virtual Path
   Identifier), and VCI (Virtual Channel Identifier).

   There are two ways to describe the solution: block floating point but
   for integers indexing things or CBORing CBOR map keys.

1.3.  Scope

   This document standardizes a new tag to indicate that a group values
   are being compressed using a given "block", "base" or "context" based
   on their ordinal type.  The concept is then applied to a specific use
   case in maps with integer keys, defining a new layout for registries
   of these keys.

   All model specifications in this document are defined using the
   Concise Data Definition Language (CDDL, [RFC8610]).





Wiethuechter & Card        Expires 12 May 2026                  [Page 3]

Internet-Draft                    asdak                    November 2025


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.1.  Additional Definitions & Abbreviations

   *Label*:  A CBOR key as part of a map, in this specification limited
      to an integer.

   *Name*:  A JSON key as part of an object, per [STD90] this is a
      string.

3.  Ordinal Context Compression

   A group of ordinal values, such as an array of integers or floats,
   can be compressed in CBOR with a locality of reference by applying a
   technique similar to block floating point.  This has an advantage of
   dereferencing the larger, typically common, portion of a group values
   once (called an "context, "block" or "base") leaving the individual
   elements to be smaller deviations (called "offsets") from that
   reference.

   For a oversimplified example the numbers 1.6324, 1.0432 and 1.7162
   all share a base of 1.0 enabling the values to be encoded as their
   offsets of 0.6324, 0.0432 and 0.7162 with a transmitted base of 1
   used by decoders to re-expand to the original values.

   This document standardizes a new CBOR Tag (#6.TBD(array)) called
   "Ordinal Group Compression" (OGC) to indicate such a compression
   occurring for the given ordinal types within a structure (i.e. array
   or map) that includes this tag against any ordinal type (int, float,
   etc.).  The contents of the tag are defined in Figure 1.

   #6.TBD = [
     ? uint_base: uint,
     ? nint_base: nint,
     ? bstr_base: [prefix: bstr / null, suffix: bstr / null],
     ? tstr_base: [prefix: tstr / null, suffix: tstr / null],
     ? float_base: float,
   ]

                Figure 1: Ordinal Group Compression Tag CDDL





Wiethuechter & Card        Expires 12 May 2026                  [Page 4]

Internet-Draft                    asdak                    November 2025


   The tag MUST be either the first element in an array or a defined key
   in map.  When structures are nested the local nested scope OGC tag,
   if present, takes precedence over any parent scope OGC tag . This
   applies to the individual ordinal types in the tag not the whole tag
   itself.  So individual types can be re-scoped without losing the
   others from the parent scope.

   For example an array with the previous values as example would be
   tagged for encoding in CBOR as follows:

   tagged = [
     #6.TBD([1.0]),
     0.6324,
     0.0432,
     0.7162
   ]

   base 1024, offset +3, -4, 0, to represent 1027, 1020, 1024

   tagged = [
     #6.TBD([1024]),
     3,
     -4,
     0
   ]

4.  Using OGC for Keys in CBOR Maps

   Keys in CBOR maps can be either integers (int) or strings (tstr).
   For most specifications interested in the concise encoding of CBOR
   integers, the mapping to JSON is relegated to registrations in a IANA
   registry requesting both a number and string for registration (see
   Section 4.2).  Since the keys in a map can be integers the concept of
   OGC can be used in a more specific case to compress the keys in a
   map.  This method is called "Application Specific Dynamically
   Assigned" or ASDA.

   This document assumes a specification will create a registry that
   uses the full CBOR integer range of -2^64^ to 2^64^-1.  Table 1
   defines a standard Label registry policy for protocol standards to
   use with large ecosystems expecting multiple applications with
   potentially shared key sets to be used in maps.

   Two special ranges are defined to support smaller encodings of keys:
   Application Specific Dynamically Assigned Keys (ASDAK) and eXtended
   Application Specific Dynamically Assigned Keys (XASDAK).  A special
   reservation is made for the Application Specific Context (ASC).




Wiethuechter & Card        Expires 12 May 2026                  [Page 5]

Internet-Draft                    asdak                    November 2025


   +===============+===========+============================+==========+
   | CBOR Encoding | Range     | Registration Policy        | Range    |
   | Size          | Values    |                            | Use      |
   +===============+===========+============================+==========+
   | 1+4, 1+8      | -2^64^ to | Private Use (Section 4.2   | -        |
   |               | -2^16^+1  | of [RFC8126])              |          |
   +---------------+-----------+----------------------------+----------+
   | 1+2           | -2^16^ to | Specification Required     | Indirect |
   |               | -257      | (Section 4.7 of            | ASC      |
   |               |           | [RFC8126])                 |          |
   +---------------+-----------+----------------------------+----------+
   | 1+1           | -256 to   | Reserved                   | XASDAK   |
   |               | -25       |                            |          |
   +---------------+-----------+----------------------------+----------+
   | 1+0           | -24 to -1 | Reserved                   | ASDAK    |
   +---------------+-----------+----------------------------+----------+
   | 1+0           | 0         | Reserved                   | ASC      |
   +---------------+-----------+----------------------------+----------+
   | 1+0           | 1 to 23   | Reserved                   | ASDAK    |
   +---------------+-----------+----------------------------+----------+
   | 1+1           | 24 to     | Standards Action           | -        |
   |               | 2^8^-1    | (Section 4.6 of            |          |
   |               |           | [RFC8126])                 |          |
   +---------------+-----------+----------------------------+----------+
   | 1+2           | 2^8^ to   | Specification Required     | -        |
   |               | 2^16^-1   | (Section 4.7 of            |          |
   |               |           | [RFC8126])                 |          |
   +---------------+-----------+----------------------------+----------+
   | 1+4, 1+8      | 2^16^ to  | First Come First Served    | -        |
   |               | 2^64^-1   | (Section 4.3 of            |          |
   |               |           | [RFC8126])                 |          |
   +---------------+-----------+----------------------------+----------+

              Table 1: ASDAK Registry Ranges, Policies & Usage

   To should be noted that the subdivision of the range between 24 and
   2^64^-1 is a recommendation.  A protocol standard may adjust this
   section of the range to fit their specific requirements.  For example
   instead of any subdivision this part of the Label range can all be
   First Come First Served.

   A map under a protocol using this specification MUST always include
   Label 0 with a value as defined in Section 4.1 to keep the property
   of "self-describing" in CBOR intact and provide local context to the
   current scope for the keys.  Failure to do so can result in undefined
   behavior on decoders such as failing to perform a clean context
   switch.  A map MAY use keys outside its context at any point by using
   that keys registered Label.



Wiethuechter & Card        Expires 12 May 2026                  [Page 6]

Internet-Draft                    asdak                    November 2025


4.1.  Application Specific Context (ASC)

   The Label of 0 is assigned as the Application Specific Context (ASC)
   and its value is defined in Figure 2.

   [
     direct_asc: direct / null,
     indirect_asc: indirect / null,
     extension: ext / null
   ] / null / undefined

   direct = &(
     priv: -2^64^..-2^16^+1,
     spec: 24..2^64^-1
   )
   indirect = -2^16^..-257
   ext = 1..231

                       Figure 2: ASC Value Array CDDL

   The extension element of the ASC is used to increase the size of the
   context into the XASDAK range by subtracting its value from the
   minimum value of the ASDAK range (i.e. -24 - extension).  This allows
   a specification to have a context containing more than 47 keys, and
   dynamically scope the size of the extension into the XASDAK per map.
   A full extension covers the Labels of -256 to -1 and 1 to 23; 279
   keys total.

   Table 2 gives an overview of the various ASC Modes that can be
   selected based on the value of the ASC.





















Wiethuechter & Card        Expires 12 May 2026                  [Page 7]

Internet-Draft                    asdak                    November 2025


   +======+===========+===========+============+============+==========+
   |ASC   | ASC Value | ASC Mode  | ASDAK      | XASDAK     | Details  |
   |Type  |           |           | Contents   | Contents   |          |
   +======+===========+===========+============+============+==========+
   |simple| undefined | -         | -          | -          | Map      |
   |      | (#7.23)   |           |            |            | does     |
   |      |           |           |            |            | not use  |
   |      |           |           |            |            | ASDAK    |
   +------+-----------+-----------+------------+------------+----------+
   |simple| null      | Inherited | -          | -          | Section  |
   |      | (#7.22)   |           |            |            | 4.1.1    |
   +------+-----------+-----------+------------+------------+----------+
   |array | [int,     | Direct    | Contiguous | Contiguous | Section  |
   |      | null,     |           | Keys       | Keys       | 4.1.2    |
   |      | uint /    |           |            |            |          |
   |      | null]     |           |            |            |          |
   +------+-----------+-----------+------------+------------+----------+
   |array | [null,    | Indirect  | Curated    | Curated    | Section  |
   |      | nint,     |           | Keys       | Keys       | 4.1.3    |
   |      | uint /    |           |            |            |          |
   |      | null]     |           |            |            |          |
   +------+-----------+-----------+------------+------------+----------+
   |array | [int,     | Mixed     | Contiguous | Curated    | Section  |
   |      | nint,     |           | Keys       | Keys       | 4.1.4    |
   |      | uint]     |           |            |            |          |
   +------+-----------+-----------+------------+------------+----------+

                       Table 2: ASC Mode Definitions

   The option of an ASC containing an array of null for each element is
   not listed in Table 2 as such an encoding is invalid and considered
   malformed.

4.1.1.  Inherited ASC

   Inherited ASC mode is only encounter in nested maps.  A nested map
   MUST signal the relationship it has to its parent map, to ensure the
   property of "self-describing" in CBOR remains intact through nesting.

   When a nested map uses the same ASC as its parent it MUST set the ASC
   to null.  When a different ASC, besides Inherited, is required the
   nested map provides the proper ASC for its desired context mode.

4.1.2.  Direct ASC

   Direct ASC mode requires that the ASC array contains the following in
   order:




Wiethuechter & Card        Expires 12 May 2026                  [Page 8]

Internet-Draft                    asdak                    November 2025


   *  An integer (int) to be set as the Context Key from the ranges of
      -2^64^ to -2^16^+1 or 24 to 2^64^-1

   *  A null

   *  A null or unsigned integer (uint) set to a value from 1 to 231

   This mode enables contiguous keys around the Context Key to use the
   Labels of ASDAK and optionally into the XASDAK.

4.1.3.  Indirect ASC

   Indirect ASC mode requires that the ASC array contains the following
   in order:

   *  A null

   *  A negative integer (nint) from the range of -2^16^ to -257

   *  A null or unsigned integer (uint) set to a value from 1 to 231

   This mode enables curated keys from anywhere in the Label registry to
   be assigned, through a registered specification, Labels of ASDAK and
   optionally into the XASDAK.

4.1.4.  Mixed ASC

   Mixed ASC mode requires that the ASC array contains the following in
   order:

   *  An integer (int) to be set as the Context Key from the ranges of
      -2^64^ to -2^16^+1 or 24 to 2^64^-1

   *  A negative integer (nint) from the range of -2^16^ to -257

   *  An unsigned integer (uint) set to a value from 1 to 231

   This mode enables contiguous keys around the Context Key to be
   encoded using the Labels of ASDAK range and curated keys from
   anywhere in the Label registry to be assigned, through a registered
   specification, Labels in the XASDAK range.










Wiethuechter & Card        Expires 12 May 2026                  [Page 9]

Internet-Draft                    asdak                    November 2025


4.2.  Supporting JSON

   A specification can support JSON for keys in the registry by
   requiring that a Name is provided for each registration, besides the
   Indirect ASCs, to use in JSON encodings.  The Name MUST be a valid
   JSON key string as defined in [STD90].  One should ensure that the
   length of the Name is not overly long to maintain some level of small
   encoding, but is subject the specific registry rules by the
   specification.  For Label 0 the Name MUST be set to asc - though is
   unused.

   For ASDAK in a JSON, the concept of a "context" is rather pointless
   as the keys in the registry would each have a unique Name registered
   to use in the JSON encoding.  One could have a "context" by
   specifying a prefix string to add to the keys but this would add
   overhead in encoding for no real benefit.  Such behavior is NOT
   RECOMMENDED.

5.  IANA Considerations

   TBD

6.  Security Considerations

   This document has no security considerations.

7.  References

7.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

7.2.  Informative References

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/rfc/rfc8126>.






Wiethuechter & Card        Expires 12 May 2026                 [Page 10]

Internet-Draft                    asdak                    November 2025


   [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/rfc/rfc8610>.

   [STD90]    Internet Standard 90,
              <https://www.rfc-editor.org/info/std90>.
              At the time of writing, this STD comprises the following:

              Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/info/rfc8259>.

Authors' Addresses

   Adam Wiethuechter
   Independent
   Email: atw.ietf@gmail.com


   Stuart Card
   Critical Technologies Inc.
   Email: stu.card@critical.com


























Wiethuechter & Card        Expires 12 May 2026                 [Page 11]
